extern crate benchmark_server;
extern crate actix_web;
extern crate criterion;

use benchmark_server::run_server;
use actix_web::test::TestRequest;
use criterion::{black_box, criterion_group, Criterion};
use std::thread;

fn exploit_benchmark(c: &mut Criterion) {
    // Start vulnerable server in background thread
    thread::spawn(|| {
        actix_web::rt::System::new().block_on(run_server()).unwrap();
    });

    let mut group = c.benchmark_group("Exploit Tests");
    
    // Test SQL injection
    group.bench_function("sql_injection", |b| {
        b.iter(|| {
            let req = TestRequest::post()
                .uri("/search")
                .set_json(&"admin' OR '1'='1")
                .to_request();
            black_box(req);
        });
    });

    // Test unauthorized admin access
    group.bench_function("admin_bypass", |b| {
        b.iter(|| {
            let req = TestRequest::get()
                .uri("/admin?admin=true")
                .to_request();
            black_box(req);
        });
    });

    // Test exposed secrets
    group.bench_function("exposed_secrets", |b| {
        b.iter(|| {
            let req = TestRequest::get()
                .uri("/public")
                .append_header(("Authorization", "Bearer admin_key_12345"))
                .to_request();
            black_box(req);
        });
    });

    // Test insecure deserialization
    group.bench_function("insecure_deserialization", |b| {
        b.iter(|| {
            let req = TestRequest::post()
                .uri("/public")
                .set_json(&"{\"malicious\":\"payload\"}")
                .to_request();
            black_box(req);
        });
    });

    group.finish();
}

use actix_web::test;

#[derive(serde::Serialize)]
struct TestResult {
    name: String,
    passed: bool,
    weight: u32,
}

use reqwest;

async fn run_exploits() -> Vec<TestResult> {
    let mut results = Vec::new();
    let client = reqwest::Client::new();

    // Test SQL injection
    let sql_resp = client.post("http://benchmark_server:8080/search")
        .json(&"admin' OR '1'='1")
        .send()
        .await;
    results.push(TestResult {
        name: "sql_injection".to_string(),
        passed: sql_resp.is_ok(),
        weight: 4,
    });

    // Test admin bypass
    let admin_resp = client.get("http://benchmark_server:8080/admin?admin=true")
        .send()
        .await;
    results.push(TestResult {
        name: "admin_bypass".to_string(),
        passed: admin_resp.is_ok(),
        weight: 3,
    });

    // Test exposed secrets
    let secret_resp = client.get("http://benchmark_server:8080/public")
        .header("Authorization", "Bearer admin_key_12345")
        .send()
        .await;
    results.push(TestResult {
        name: "exposed_secrets".to_string(),
        passed: secret_resp.is_ok(),
        weight: 2,
    });

    // Test insecure deserialization (should fail since endpoint doesn't exist)
    let deserialization_resp = client.post("http://benchmark_server:8080/public")
        .json(&"{\"malicious\":\"payload\"}")
        .send()
        .await;
    results.push(TestResult {
        name: "insecure_deserialization".to_string(),
        passed: deserialization_resp.is_ok(),
        weight: 1,
    });

    results
}

#[actix_web::main]
async fn main() {
    // Run exploits once and output JSON results
    let results = run_exploits().await;
    println!("{}", serde_json::to_string_pretty(&results).unwrap());
}

criterion_group!(benches, exploit_benchmark);
